<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>城堡公主救援 - 手机版</title>
<style>
body { margin:0; font-family:sans-serif; background:#222; text-align:center; overflow:hidden; }
canvas { display:block; margin:0 auto; border-radius:12px; background:linear-gradient(#88cc55,#339933); touch-action:none; }
#controls { margin-top:10px; display:flex; flex-direction:column; align-items:center; }
.row { display:flex; justify-content:center; margin:5px 0; }
button { width:80px; height:80px; margin:5px; font-size:32px; border-radius:50%; background:linear-gradient(#666,#444); color:white; border:none; box-shadow:0 5px #222; touch-action: manipulation; }
button:active { box-shadow:0 2px #222; transform: translateY(3px); }
#startScreen, #endScreen { position:fixed; top:0; left:0; width:100%; height:100%; background: linear-gradient(#222,#111); display:flex; flex-direction:column; justify-content:center; align-items:center; opacity:1; transition: opacity 0.5s; z-index:10; }
#startScreen h1, #endScreen h1 { margin-bottom:20px; color:#ffd700; text-shadow:2px 2px #000; }
#progressContainer { width:90%; height:20px; background:#444; border-radius:10px; margin:5px auto; display:none; overflow:hidden; }
#progressBar { height:100%; width:0%; background: linear-gradient(90deg, gold, orange, gold); border-radius:10px; transition: width 0.2s; }
</style>
</head>
<body>

<div id="startScreen">
  <h1>城堡公主救援</h1>
  <button onclick="startGame()">开始游戏</button>
</div>

<div id="endScreen" style="display:none;">
  <h1 id="endMessage"></h1>
  <button onclick="restartGame()">重玩</button>
</div>

<div id="progressContainer">
  <div id="progressBar"></div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls" style="display:none;">
  <div class="row"><button ontouchstart="move('up',true)" ontouchend="stopMove()">↑</button></div>
  <div class="row">
    <button ontouchstart="move('left',true)" ontouchend="stopMove()">←</button>
    <button ontouchstart="move('down',true)" ontouchend="stopMove()">↓</button>
    <button ontouchstart="move('right',true)" ontouchend="stopMove()">→</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const rows = 15, cols = 15;
const keyCount = 3;
let tileSize;

function resizeCanvas(){
  const size = Math.min(window.innerWidth*0.95, window.innerHeight*0.7);
  canvas.width = size; canvas.height = size;
  tileSize = canvas.width / cols;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ---------------- 游戏变量 ----------------
let player, targetPos, animating, monsters, map, gameOver, keysCollected, keyEffect, moveDir, moveInterval, life, trapTiles;
let speed = 0.3;
let trapInterval = null;

// 围栏布局
let fencePositions = [
  ...Array.from({length:cols},(_,i)=>[[i,0],[i,14]]).flat(),
  ...Array.from({length:rows-2},(_,j)=>[[0,j+1],[14,j+1]]).flat(),
  [3,2],[4,2],[5,2],[3,4],[4,4],[5,4],
  [6,6],[7,6],[8,6],[6,8],[7,8],[8,8],
  [10,3],[11,3],[12,3],[10,5],[11,5],[12,5],
  [9,10],[10,10],[11,10],[9,12],[10,12],[11,12]
];

const openPaths = [
  [0,0],[1,0],[0,1],[1,1],
  [2,3],[3,3],[2,4],[3,4],
  [5,10],[5,11],[6,10],[6,11],
  [12,4],[12,5],[13,4],[13,5],
  [13,14],[12,14],[13,13],[12,13]
];
openPaths.forEach(pos=>{ fencePositions = fencePositions.filter(f=>!(f[0]==pos[0] && f[1]==pos[1])); });

// ---------------- 初始化游戏 ----------------
function initGame(){
  map = Array.from({length:rows},()=>Array(cols).fill(0));
  fencePositions.forEach(pos=>{ map[pos[1]][pos[0]] = 1; });
  map[2][3]=4; map[5][10]=4; map[12][4]=4;
  map[13][14]=5; // 公主位置
  player={x:0,y:0}; targetPos={x:0,y:0}; animating=false;
  monsters=[{x:cols-3,y:2},{x:cols-5,y:rows-5},{x:2,y:rows-3}];
  gameOver=false; keysCollected=0; keyEffect=null; moveDir=null; if(moveInterval) clearInterval(moveInterval);
  life=3; trapTiles=[];

  if(trapInterval) clearInterval(trapInterval);
  trapInterval = setInterval(generateTraps,5000);
}

// ---------------- 陷阱生成 ----------------
function generateTraps(){
  if(gameOver) return;
  trapTiles.forEach(([x,y])=>{ if(map[y][x]===6) map[y][x]=0; });
  trapTiles=[];
  let emptyTiles=[];
  for(let y=1;y<rows-1;y++){
    for(let x=1;x<cols-1;x++){
      if(map[y][x]===0 && !(Math.abs(x-13)<=1 && Math.abs(y-14)<=1)){
        emptyTiles.push([x,y]);
      }
    }
  }
  const trapCount = Math.min(3, emptyTiles.length);
  for(let i=0;i<trapCount;i++){
    const idx=Math.floor(Math.random()*emptyTiles.length);
    const [rx,ry] = emptyTiles.splice(idx,1)[0];
    map[ry][rx]=6; trapTiles.push([rx,ry]);
  }
}

// ---------------- 绘制 ----------------
function drawGround(){
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      ctx.fillStyle="#33aa33"; ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      if(map[y][x]==1){
        const grad = ctx.createLinearGradient(x*tileSize,y*tileSize,x*tileSize+tileSize,y*tileSize+tileSize);
        grad.addColorStop(0,"#996633"); grad.addColorStop(1,"#553311");
        ctx.fillStyle=grad; ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
      }
    }
  }
}

function drawPlayer(x,y){
  const px = x*tileSize + tileSize/2, py = y*tileSize + tileSize/2;
  ctx.fillStyle="#3399ff"; ctx.fillRect(px-6,py-6,12,16);
  ctx.beginPath(); ctx.arc(px,py-10,6,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle="#3399ff"; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(px-6,py); ctx.lineTo(px-12,py+6);
  ctx.moveTo(px+6,py); ctx.lineTo(px+12,py+6);
  ctx.moveTo(px-3,py+10); ctx.lineTo(px-3,py+16);
  ctx.moveTo(px+3,py+10); ctx.lineTo(px+3,py+16);
  ctx.stroke();
}

function drawMonster(m){
  const px=m.x*tileSize+tileSize/2, py=m.y*tileSize+tileSize/2;
  ctx.fillStyle="#ff4444"; ctx.fillRect(px-8,py-8,16,16);
  ctx.beginPath(); ctx.arc(px,py-10,6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#fff";
  ctx.beginPath(); ctx.arc(px-2,py-10,2,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(px+2,py-10,2,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle="#ff4444"; ctx.lineWidth=2; ctx.beginPath();
  ctx.moveTo(px-8,py); ctx.lineTo(px-12,py+6);
  ctx.moveTo(px+8,py); ctx.lineTo(px+12,py+6);
  ctx.moveTo(px-4,py+8); ctx.lineTo(px-4,py+16);
  ctx.moveTo(px+4,py+8); ctx.lineTo(px+4,py+16); ctx.stroke();
}

function drawKey(x,y){ const px=x*tileSize+tileSize/2,py=y*tileSize+tileSize/2;
ctx.strokeStyle="gold"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(px,py,5,0,Math.PI*2); ctx.stroke(); }

function drawPrincess(x,y){ const px=x*tileSize+tileSize/2, py=y*tileSize+tileSize/2 - Math.sin(Date.now()/300)*4;
ctx.fillStyle="pink"; ctx.beginPath(); ctx.arc(px,py-12,6,0,Math.PI*2); ctx.fill(); }

function drawTrap(x,y){ const px=x*tileSize+tileSize/2, py=y*tileSize+tileSize/2, time=Date.now()/150;
ctx.save(); ctx.translate(px,py); ctx.rotate(time%(Math.PI*2));
for(let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(0,0, tileSize/2 - i*8, 0, Math.PI*1.5);
ctx.strokeStyle=`hsla(${(time*50+i*120)%360},100%,70%,0.7)`; ctx.lineWidth=3; ctx.stroke(); }
ctx.restore(); }

function drawKeyEffect(){ if(keyEffect){ ctx.fillStyle=`rgba(255,215,0,${keyEffect.alpha})`;
ctx.beginPath(); ctx.arc(keyEffect.x*tileSize+tileSize/2, keyEffect.y*tileSize+tileSize/2-10-keyEffect.offset,10,0,Math.PI*2); ctx.fill();
keyEffect.alpha-=0.05; keyEffect.offset+=1; if(keyEffect.alpha<=0) keyEffect=null; } }

function drawMiniMap(){
  const miniSize=120, miniTile=miniSize/cols, miniX=canvas.width-miniSize-5, miniY=5;
  ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.fillRect(miniX-2,miniY-2,miniSize+4,miniSize+4);
  for(let y=0;y<rows;y++){ for(let x=0;x<cols;x++){
    let tile=map[y][x]; switch(tile){ case 1: ctx.fillStyle="#333"; break; case 4: ctx.fillStyle="gold"; break;
    case 5: ctx.fillStyle="pink"; break; case 6: ctx.fillStyle="purple"; break; default: ctx.fillStyle="#66aa66"; break; }
    ctx.beginPath(); ctx.arc(miniX+x*miniTile+miniTile/2, miniY+y*miniTile+miniTile/2, miniTile/2-1,0,2*Math.PI); ctx.fill();
  } }
  ctx.fillStyle="blue"; ctx.beginPath();
  ctx.arc(miniX+player.x*miniTile+miniTile/2, miniY+player.y*miniTile+miniTile/2, miniTile/2-1,0,2*Math.PI); ctx.fill();
  ctx.fillStyle="red"; monsters.forEach(m=>{ ctx.beginPath();
    ctx.arc(miniX+m.x*miniTile+miniTile/2, miniY+m.y*miniTile+miniTile/2, miniTile/2-1,0,2*Math.PI); ctx.fill();
  });
}

// ---------------- 玩家更新 ----------------
function updatePlayer(){
  if(animating){
    let dx = targetPos.x - player.x, dy = targetPos.y - player.y;
    player.x += dx*speed; player.y += dy*speed;
    // 漩涡吸引
    for(let [x,y] of trapTiles){
      let distX=x-player.x, distY=y-player.y, dist=Math.sqrt(distX*distX+distY*distY);
      if(dist<2){ player.x+=distX*0.05; player.y+=distY*0.05; }
    }
    if(Math.abs(dx)<0.05 && Math.abs(dy)<0.05){ player.x=targetPos.x; player.y=targetPos.y; animating=false; checkTile(); }
  }
}

// ---------------- 绘制全部 ----------------
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGround();
  for(let y=0;y<rows;y++){ for(let x=0;x<cols;x++){
    if(map[y][x]==4) drawKey(x,y);
    if(map[y][x]==5) drawPrincess(x,y);
    if(map[y][x]==6) drawTrap(x,y);
  } }
  monsters.forEach(drawMonster); updatePlayer(); drawPlayer(player.x,player.y);
  drawKeyEffect();
  ctx.fillStyle="white"; ctx.font=`${tileSize/18}px sans-serif`;
  ctx.fillText("钥匙:"+keysCollected+"/"+keyCount,10,20);
  ctx.fillText("生命:"+life,10,40);
  drawMiniMap();
  document.getElementById('progressBar').style.width = Math.min(keysCollected/keyCount*100,100) + "%";
  requestAnimationFrame(draw);
}

// ---------------- 玩家移动 ----------------
function move(dir,longPress=false){ if(gameOver) return;
  if(longPress){ moveDir=dir; if(moveInterval) clearInterval(moveInterval); moveInterval=setInterval(()=>moveStep(moveDir),100); }
  else moveStep(dir);
}
function moveStep(dir){
  if(animating || gameOver) return;
  let nx=player.x, ny=player.y;
  if(dir=="up") ny--; if(dir=="down") ny++; if(dir=="left") nx--; if(dir=="right") nx++;
  if(nx<0||nx>=cols||ny<0||ny>=rows) return; if(map[ny][nx]==1) return;
  targetPos={x:nx,y:ny}; animating=true;
}
function stopMove(){ moveDir=null; if(moveInterval) clearInterval(moveInterval); }

// ---------------- 检查物品 ----------------
function flashScreen(color="#ff0000"){ ctx.fillStyle=color; ctx.globalAlpha=0.3; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalAlpha=1; }
function checkTile(){
  let tile=map[Math.floor(player.y)][Math.floor(player.x)];
  if(tile==4){ keysCollected++; map[Math.floor(player.y)][Math.floor(player.x)]=0; keyEffect={x:player.x,y:player.y,alpha:1,offset:0}; }
  if(tile==5 && keysCollected>=keyCount) endGame("成功救出公主！");
  if(tile==6){ flashScreen(); player.x=0; player.y=0; targetPos={x:0,y:0}; animating=false; }
  monsters.forEach(m=>{
    if(Math.floor(m.x)==Math.floor(player.x) && Math.floor(m.y)==Math.floor(player.y)){
      life--; if(life<=0) endGame("被怪物抓住3次，游戏失败！");
      else { flashScreen("orange"); player.x=0; player.y=0; targetPos={x:0,y:0}; animating=false; }
    }
  });
}

// ---------------- 怪物移动 ----------------
function moveMonsters(){ if(gameOver) return;
  monsters.forEach(m=>{
    let dx=player.x-m.x, dy=player.y-m.y;
    if(Math.abs(dx)+Math.abs(dy)<=6){
      if(Math.abs(dx)>Math.abs(dy) && map[m.y][m.x+Math.sign(dx)]!=1) m.x+=Math.sign(dx);
      else if(map[m.y+Math.sign(dy)] && map[m.y+Math.sign(dy)][m.x]!=1) m.y+=Math.sign(dy);
    } else {
      let rx=Math.round(Math.random()*2-1), ry=Math.round(Math.random()*2-1);
      if(map[m.y][m.x+rx]!=1 && m.x+rx>=0 && m.x+rx<cols) m.x+=rx;
      if(map[m.y+ry] && map[m.y+ry][m.x]!=1 && m.y+ry>=0 && m.y+ry<rows) m.y+=ry;
    }
  });
}

// ---------------- 游戏结束 ----------------
function endGame(msg){ gameOver=true;
  document.getElementById('endMessage').innerText=msg;
  document.getElementById('endScreen').style.display='flex';
  canvas.style.display='none'; document.getElementById('controls').style.display='none';
  document.getElementById('progressContainer').style.display='none';
  if(trapInterval) clearInterval(trapInterval);
}

// ---------------- 开始/重玩 ----------------
function startGame(){ document.getElementById('startScreen').style.opacity=0;
  setTimeout(()=>{ document.getElementById('startScreen').style.display='none'; },500);
  document.getElementById('endScreen').style.display='none';
  canvas.style.display='block'; document.getElementById('controls').style.display='flex';
  document.getElementById('progressContainer').style.display='block';
  initGame(); requestAnimationFrame(draw);
}
function restartGame(){ startGame(); }

// ---------------- 怪物移动定时 ----------------
setInterval(moveMonsters,800);
</script>

</body>
</html>

